\documentclass[]{article}
\usepackage{graphicx}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=3cm, right=3cm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
%\usepackage{enumitem}


\lstset{
  language=C,
  basicstyle=\ttfamily\small,
  commentstyle=\color{gray},
  keywordstyle=\color{blue},
  stringstyle=\color{green},
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  showspaces=false,
  showstringspaces=false,
  tabsize=2,
  breaklines=true,
  captionpos=false,
}

%title
\title{Practica 1} 

\author{Adrián Ferández Galán y César López Mantecón}

\begin{document}

\begin{titlepage}
    \centering
   \includegraphics[width=0.9\textwidth]{uc3m.jpg} 
    {\Huge Universidad Carlos III\\
    
     \Large Sistemas Distribuídos\\
     \vspace{0.5cm}
     Curso 2023-24}
    \vspace{2cm}

    {\Huge \textbf{Práctica 1} \par}
    \vspace{0.5cm}
    {\Large Colas de mensajes POSIX \par}
    \vspace{8cm}

   \textbf{Ingeniería Informática, Tercer curso}\\
    \vspace{0.2cm} 
    Adrián Fernández Galán (NIA: 100472182, e-mail: 100472182@alumnos.uc3m.es) \\
    César López Mantecón   (NIA: 100472092, e-mail: 100472092@alumnos.uc3m.es)
    \vspace{0.5cm}

   
    \textbf{Prof .} Félix García Caballeira\\
    \textbf{Grupo: } 81   
    
\end{titlepage}
\newpage

\renewcommand{\contentsname}{\centering Índice}
\tableofcontents

\newpage

\section{Introducción}
\label{sec:introduccion}
El desarrollo de este proyecto consiste en implementar una aplicación cliente-servidor, donde los diferentes clientes podrán guardar información en tuplas a través del servidor, de forma transparente.
Para que esto pueda darse se pide que la comunicación entre los clientes y el servidor se de a través de colas POSIX.
Es importante destacar que para el tratamiento de las solicitudes el servidor será concurrente, utilizando hilos.

\section{Diseño}
\label{sec:disenno}
La aplicación constará de dos partes diferenciadas: los clientes y el servidor.

\subsection{Cliente y Biblioteca dinámica}
\label{subsec:cliente_biblioteca}
El cliente estará formado por dos partes, el main de cliente, que corresponde con el fichero \textit{src/cliente.c}, y la comunicación con el servidor, que corresponde con el fichero \textit{/src/clave.c}. Esta último se compilará como una librería dinámica \textit{lib.so} de forma que la comunicación sea independiente de la implementación de cliente. De esta forma, logramos una aplicación que, en caso de cambiar la forma de comunicación o implementación de los servicios no sea necesario volver a compilar siempre que se respete la interfaz actual. 

Para compilar el archivo \textit{claves.c} se ha empleado el siguiente comando en un archivo \textit{Makefile}.

\begin{center}
\begin{lstlisting}[caption=Compiación de biblioteca dinámica]
gcc -c -fPIC -shared -o lib.so claves.c
\end{lstlisting}
\end{center}

El  cliente podrá llamar a las  las diferentes funciones ofrecidas por la interfaz, de esta manera se podrá interactuar con las distintas tuplas almacenadas. Los servicios, no obstante, estarán implementados en el servidor de forma transparente al usuario.
En esta implementación cada cliente creará una peticición que corresponda con la funcionalidad invocada y creará una cola POSIX que le corresponde, donde se recibirá la respuesta, y abrirá la cola POSIX que le corresponde al servidor, donde volcará su petición y procederá a esperar la respuesta.

\subsection{Servidor}
\label{subsec:servidor}
En el servidor se encuentran las funcionalidades que se encargan de la comunicación con el cliente, es decir \textit{src/servidor.c}, y la correspondiente implementación de las tuplas, es decir \textit{src/imp\_clave.c}.

\subsubsection{Estructura del Servidor}
\label{subsec::estructura_servidor}
En cuanto a la parte de comunicación con el cliente, el servidor abre su cola POSIX y espera de forma indefinida a que los clientes realicen sus peticiones. En el momento en el que llega una petición el servidor analizará la petición y llamará a la funcionalidad que el cliente haya pedido. Cuando la funcionalidad se haya realizado se volcará en contenido de respuesta en la cola de cliente.
Para la implenetación de las distintas funcionalidades se ha optado por guardar las tuplas en ficheros, lo que nos permite acceder a las tuplas en distintas sesiones, ya que se guardan en la memoria permanente.
Para poder crear y destruir simplemente creamos los ficheros y los borramos, y para leer y escribir abrimos el fichero y volcamos los datos de manera binaria.

\subsubsection{Concurrencia del Servidor}
\label{subsec::concurrencia_servidor}


\subsection{Mensajes}
\label{subsec:mensajes}
Para el proceso de comunicación necesitamos realizar un paso de mensajes, que se vuelquen en las correspondientes colas POSIX. Para almacenar distintos valores los mensajes utilizan arrays ya que para no pueden usarse punteros debido a que los mensajes viajarán entre procesos y por lo tanto no pueden referirse a la memoria de un proceso en concreto.
Para ello se han construido 2 estructuras: la petición y la respuesta
\subsubsection{Petición}
\label{subsec::peticion}
Para construir la peticición nos hemos basado en los argumentos de entrada que tenían todos los prototipos de las funciones. A continuación nos pararemos en cada uno de los atributos de la estructura.

%\begin{itemize}
  % \textit{q_client}: Este atributo es necesario para identificar el nombre de la cola del cliente que ha realizado la petición con el objetivo de que el servidor pueda devolver una respuesta al cliente.
  % \textit{key}: El valor que corresponde a este atributo se utiliza en las funciones para identificar la tupla de forma inequivoca.
  %\textit{op}: El valor que se coloca en este atributo corresponde al tipo de función con la que se debe de trabajar
  % \textit{value1}: El valor que se almacena en este atributo es la cadena que se utiliza como clave en la tupla.
  % \textit{N_i}: Esta variable de tipo entero se utiliza como longitud para escribir el array de doubles o como índice para leer este array.
  % \textit{V_value2}: Esta variable almacena el array de doubles que corresponde con el valor que se almacena en las tuplas.
% \end{itemize}

\subsubsection*{Respuesta}
\label{subsec::respuesta}




\subsection{Uso de ficheros}
\label{subsec:uso_de_ficheros}



\section{Descripción de pruebas}
\label{sec:descripcion_de_pruebas}
Pruebas que hemos ejecutado sobre nuestra aplicación: ejecución con varios clientes, validación de las funciones... Creo que lo mejor sería dividirlo en subsecciones, una para cada función, otra para las comunicaciones y otra para la concurrencia. 



\section{Conclusiones}
\label{sec:conclusiones}
Escribimos aquí


\end{document}
